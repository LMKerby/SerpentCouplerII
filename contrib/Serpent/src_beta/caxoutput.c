/*****************************************************************************/
/*                                                                           */
/* serpent 2 (beta-version) : caxoutput.c                                    */
/*                                                                           */
/* Created:       2013/03/02 (JLe)                                           */
/* Last modified: 2013/04/26 (JLe)                                           */
/* Version:       2.1.13                                                     */
/*                                                                           */
/* Description: Writes output for simulator codes in CASMO card image file   */
/*              format                                                       */
/*                                                                           */
/* Comments: - Testaa CASMO:lla FUM:in vaikutusta POL-korttiin (esim 2g k)   */
/*                                                                           */
/*                                                                           */
/*****************************************************************************/

#include "header.h"
#include "locations.h"

#define FUNCTION_NAME "CAXOutput:"

/*****************************************************************************/

void CAXOutput()
{
  long loc0, stp, nfg, ptr, m, n, type;
  double fiss, fiss1, fiss2, kinf, avg, flx1, flx2, sig12, sig21, rem;
  double abs1, abs2, nsf, nsf1, nsf2, D1, D2, M2, k, B2, yld;
  char outfile[MAX_STR], tit[MAX_STR];
  FILE *fp;

  /* Check option */

  if ((long)RDB[DATA_CAX_OUTPUT] == NO)
    return;

  /* Check mpi task */

  if (mpiid > 0)
    return;

  /* Check corrector step */

  if ((long)RDB[DATA_BURN_STEP_PC] == CORRECTOR_STEP) 
    return;

  /* Open file for writing */

  sprintf(outfile, "%s.cax", GetText(DATA_PTR_INPUT_FNAME));
  if ((fp = fopen(outfile, "w")) == NULL)
    Die(FUNCTION_NAME, "Unable to open file for writing");

  /* Reset state point */

  stp = 0;

  /* Loop over state points */

  loc0 = (long)RDB[DATA_PTR_SIM0];
  while (loc0 > VALID_PTR)
    {
      /* Update statepoint (only last 3 digits are printed) */

      stp++;
      if (stp == 1001)
	stp = 1;

      /* Get number of energy groups */

      nfg = (long)RDB[loc0 + SIM_NFG];

      /* Get k-inf */

      ptr = (long)RDB[loc0 + SIM_KINF];
      CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
      kinf = RDB[ptr];

      /***********************************************************************/

      /***** TIT Data block **************************************************/

      /* Print title */
      
      sprintf(tit,"Card image file generated by %s %s", 
	      CODE_NAME, CODE_VERSION);


      /* Card 1 */

      fprintf(fp, "%-72s%2d%3d%3ld\n", "TIT", 1, 1, stp);
      fprintf(fp, "*          %-69s\n", tit);

      /***********************************************************************/

      /***** ADF Data block **************************************************/

      /* Card 1 */

      fprintf(fp, "%-72s%2d%3ld%3ld\n", 
	      "ADF     WEST       SOUTH        EAST       NORTH         AVE", 
	      1, nfg*4 + 5, stp);
	  
      /* Get ADF surface type */

      type = (long)RDB[loc0 + SIM_ADF_SURF_TYPE];

      /* Check type */

      if ((type == SURF_SQC) || (type == SURF_CUBOID))
	{
	  /* Card 2 (number of energy groups and quarter bundle edits) */
	  
	  fprintf(fp, "%6ld%6d\n", nfg, 1);

	  /* Card 3 (Assembly discontinuity factors) */
	  
	  ptr = (long)RDB[loc0 + SIM_ADFS];
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  /* Loop over energy groups */
	  
	  for (m = 0; m < nfg; m++)
	    {
	      /* Reset average */
	      
	      avg = 0.0;
	      
	      /* W-S-E-N */
	      
	      fprintf(fp, "%12.5E", RDB[ptr + m]);
	      avg = avg + RDB[ptr + m];

	      fprintf(fp, "%12.5E", RDB[ptr + 3*nfg + m]);
	      avg = avg + RDB[ptr + 3*nfg + m];

	      fprintf(fp, "%12.5E", RDB[ptr + 2*nfg + m]);
	      avg = avg + RDB[ptr + 2*nfg + m];

	      fprintf(fp, "%12.5E", RDB[ptr + nfg + m]);
	      avg = avg + RDB[ptr + nfg + m];
	      
	      /* Print average */
	      
	      fprintf(fp, "%12.5E", avg/4.0);
	      fprintf(fp, "%18s%-2ld\n", "ADF", m + 1);
	    }
	  
	  /* Card 4 (Net incurrents and k-inf) */
	  
	  ptr = (long)RDB[loc0 + SIM_ADF_NET_INCURR];
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);

	  for (m = 0; m < nfg; m++)
	    {
	      /* Reset average */
	      
	      avg = 0.0;

	      /* W-S-E-N */
	      
	      fprintf(fp, "%12.5E", RDB[ptr + m]);
	      avg = avg + RDB[ptr + m];

	      fprintf(fp, "%12.5E", RDB[ptr + 3*nfg + m]);
	      avg = avg + RDB[ptr + 3*nfg + m];

	      fprintf(fp, "%12.5E", RDB[ptr + 2*nfg + m]);
	      avg = avg + RDB[ptr + 2*nfg + m];

	      fprintf(fp, "%12.5E", RDB[ptr + nfg + m]);
	      avg = avg + RDB[ptr + nfg + m];

	      /* Print average */
	      
	      fprintf(fp, "%12.5E", avg/4.0);
	      
	      if (m == nfg - 1)
		fprintf(fp, "%12.5E%6s%-2ld\n", kinf, "CURR", m + 1);
	      else
		fprintf(fp, "%18s%-2ld\n", "CURR", m + 1);
	    }
	  
	  /* Card 5 (Surface fluxes) */ 

	  for (m = 0; m < nfg; m++)
	    {
	      /* Pointer to data */
	  
	      ptr = (long)RDB[loc0 + SIM_ADF_SURF_FLX];
	      CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	      /* Reset average */
	      
	      avg = 0.0;
	      
	      /* W-S-E-N */
	      
	      fprintf(fp, "%12.5E", RDB[ptr + m]);
	      avg = avg + RDB[ptr + m];

	      fprintf(fp, "%12.5E", RDB[ptr + 3*nfg + m]);
	      avg = avg + RDB[ptr + 3*nfg + m];

	      fprintf(fp, "%12.5E", RDB[ptr + 2*nfg + m]);
	      avg = avg + RDB[ptr + 2*nfg + m];

	      fprintf(fp, "%12.5E", RDB[ptr + nfg + m]);
	      avg = avg + RDB[ptr + nfg + m];

	      /* Print average */
	      
	      fprintf(fp, "%12.5E", avg/4.0);

	      /* Print cell flux */

	      ptr = (long)RDB[loc0 + SIM_ADF_VOL_FLX];
	      CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	      fprintf(fp, "%12.5E", RDB[ptr + m]);

	      fprintf(fp, "%6s%-2ld\n", "SURF", m + 1);
	    }
	  
	  /* Card 6 (Corner fluxes) */ 

	  ptr = (long)RDB[loc0 + SIM_ADF_CORN_FLX];
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  for (m = 0; m < nfg; m++)
	    {
	      /* Reset average */
	      
	      avg = 0.0;
	      
	      /* NW-SW-SE-NE */

	      fprintf(fp, "%12.5E", RDB[ptr + 3*nfg + m]);
	      avg = avg + RDB[ptr + 3*nfg + m];
	      
	      fprintf(fp, "%12.5E", RDB[ptr + m]);
	      avg = avg + RDB[ptr + m];
     
	      fprintf(fp, "%12.5E", RDB[ptr + nfg + m]);
	      avg = avg + RDB[ptr + nfg + m];

	      fprintf(fp, "%12.5E", RDB[ptr + 2*nfg + m]);
	      avg = avg + RDB[ptr + 2*nfg + m];
	      
	      /* Print average */
	      
	      fprintf(fp, "%12.5E", avg/4.0);
	      fprintf(fp, "%18s%-2ld\n", "CORN", m + 1);
	    }
	  
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E\n", 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E\n", 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E\n", 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E\n", 0.0, 0.0, 0.0, 0.0);
	}
      else
	{
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E%12.5E\n", 
		  0.0, 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E%12.5E\n", 
		  0.0, 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E%12.5E\n", 
		  0.0, 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E%12.5E%12.5E\n", 
		  0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E%12.5E\n", 
		  0.0, 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E%12.5E\n", 
		  0.0, 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E%12.5E\n", 
		  0.0, 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E%12.5E\n", 
		  0.0, 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E\n", 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E\n", 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E\n", 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E\n", 0.0, 0.0, 0.0, 0.0);
	  
	}

      /***********************************************************************/

      /***** POL Data block (2-group constants) ******************************/

      /* Card 1 */
      
      fprintf(fp, "%-72s%2d%3d%3ld\n", "POL", 1, 6, stp);

      /* Check number of groups */

      if (nfg == 2)
	{
	  /* Get flux */
	  
	  if ((long)RDB[DATA_B1_CALC] == NO)
	    ptr = (long)RDB[loc0 + SIM_INF_FLX];
	  else
	    ptr = (long)RDB[loc0 + SIM_B1_FLX];
	  
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  flx1 = RDB[ptr];
	  flx2 = RDB[ptr + 1];

	  /* Check */

	  if (flx1 + flx2 < ZERO)
	    Die(FUNCTION_NAME, "Zero flux");
	  
	  /* Get group-to-group scattering cross sections */
	  
	  if ((long)RDB[DATA_B1_CALC] == NO)
	    ptr = (long)RDB[loc0 + SIM_INF_S0];
	  else
	    ptr = (long)RDB[loc0 + SIM_B1_S0];
	  
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  sig12 = RDB[ptr + 1];
	  sig21 = RDB[ptr + 2];
	  
	  /* Calculate removal */
	  
	  if (flx1 > 0.0)
	    rem = sig12 - flx2/flx1*sig21;
	  else
	    rem = 0.0;
	  
	  /* Get nsf */
	  
	  if ((long)RDB[DATA_B1_CALC] == NO)
	    ptr = (long)RDB[loc0 + SIM_INF_NSF];
	  else
	    ptr = (long)RDB[loc0 + SIM_B1_NSF];
	  
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  nsf1 = RDB[ptr];
	  nsf2 = RDB[ptr + 1];
	  
	  /* Calculate total nsf */

	  nsf = (nsf1*flx1 + nsf2*flx2)/(flx1 + flx2);

	  /* Get absorption */
	  
	  if ((long)RDB[DATA_B1_CALC] == NO)
	    ptr = (long)RDB[loc0 + SIM_INF_ABS];
	  else
	    ptr = (long)RDB[loc0 + SIM_B1_ABS];
	  
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  abs1 = RDB[ptr];
	  abs2 = RDB[ptr + 1];
	  
	  /* Get diffusion coefficients */
	  
	  if ((long)RDB[DATA_B1_CALC] == NO)
	    ptr = (long)RDB[loc0 + SIM_INF_DIFFCOEF];
	  else
	    ptr = (long)RDB[loc0 + SIM_B1_DIFFCOEF];
	  
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  D1 = RDB[ptr];
	  D2 = RDB[ptr + 1];
	  
	  /* Get fission cross sections */
	  
	  if ((long)RDB[DATA_B1_CALC] == NO)
	    ptr = (long)RDB[loc0 + SIM_INF_FISS];
	  else
	    ptr = (long)RDB[loc0 + SIM_B1_FISS];
	  
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  fiss1 = RDB[ptr];
	  fiss2 = RDB[ptr + 1];

	  /* Calculate total */

	  fiss = (fiss1*flx1 + fiss2*flx2)/(flx1 + flx2);
	  
	  /* Card 2 (group constants) */
	  
	  /* Diffusion coefficients */
	  
	  fprintf(fp, "%12.5E%12.5E", D1, D2);
	  
	  /* Removal cross section */

	  fprintf(fp, "%12.5E", rem);
	  
	  /* Absorption cross sections */
	  
	  fprintf(fp, "%12.5E%12.5E", abs1, abs2);
	  
	  /* Nu*sigma_F1 */
	  
	  fprintf(fp, "%12.5E\n", nsf1);
	  
	  /* Card 3 (more group constants) */
	  
	  /* Nu*sigma_F2 */
	  
	  fprintf(fp, "%12.5E", nsf2);
	  
	  /* Nu (total) */ 
	  
	  if (fiss > 0.0)
	    fprintf(fp, "%12.5E", nsf/fiss);
	  else
	    fprintf(fp, "%12.5E", 0.0);
	  
	  /* Microscopic Xe-135 capture cross section in thermal group */ 
	  
	  if ((long)RDB[DATA_B1_CALC] == NO)
	    ptr = (long)RDB[loc0 + SIM_INF_XE135_ABS];
	  else
	    ptr = (long)RDB[loc0 + SIM_B1_XE135_ABS];
	  
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  fprintf(fp, "%12.5E", RDB[ptr + 1]);
	  
	  /* Macroscopic Xe-135 capture cross section in thermal group */ 

	  if ((long)RDB[DATA_B1_CALC] == NO)
	    ptr = (long)RDB[loc0 + SIM_INF_XE135_MACRO_ABS];
	  else
	    ptr = (long)RDB[loc0 + SIM_B1_XE135_MACRO_ABS];
	  
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  fprintf(fp, "%12.5E", RDB[ptr + 1]);
	  
	  /* Kappa (total) */ 
	  
	  if ((long)RDB[DATA_B1_CALC] == NO)
	    ptr = (long)RDB[loc0 + SIM_INF_KAPPA];
	  else
	    ptr = (long)RDB[loc0 + SIM_B1_KAPPA];

	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  if (fiss > 0.0)
	    fprintf(fp, "%12.5E", MEV*(RDB[ptr]*flx1 + RDB[ptr + 1]*flx2)/(flx1 + flx2));
	  else
	    fprintf(fp, "%12.5E", 0.0);
	  
	  /* Total Xe-135 yield */ 
	  
	  if ((long)RDB[DATA_B1_CALC] == NO)
	    ptr = (long)RDB[loc0 + SIM_INF_XE135_YIELD];
	  else
	    ptr = (long)RDB[loc0 + SIM_B1_XE135_YIELD];

	  yld = (RDB[ptr]*flx1*fiss1 + RDB[ptr + 1]*flx2*fiss2)/
	    (flx1*fiss1 + flx2*fiss2);
	  
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);

	  if ((long)RDB[DATA_B1_CALC] == NO)
	    ptr = (long)RDB[loc0 + SIM_INF_I135_YIELD];
	  else
	    ptr = (long)RDB[loc0 + SIM_B1_I135_YIELD];
	  
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  yld = yld + (RDB[ptr]*flx1*fiss1 + RDB[ptr + 1]*flx2*fiss2)/
	    (flx1*fiss1 + flx2*fiss2);
	  
	  fprintf(fp, "%12.5E\n", yld);
	  
	  /* Card 4 (more group constants) */
	  
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E", 0.0, 0.0, 0.0, 0.0);
	  
	  /* k-inf */
	  
	  fprintf(fp, "%12.5E", kinf);
	  
	  /* Power density */ 
	  
	  ptr = (long)RDB[loc0 + SIM_POWDENS];
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  fprintf(fp, "%12.5E\n", RDB[ptr]);
	  
	  /* Card 5 (more group constants) */
	  
	  /* Microscopic Sm-149 capture cross section in thermal group */ 
	  
	  if ((long)RDB[DATA_B1_CALC] == NO)
	    ptr = (long)RDB[loc0 + SIM_INF_SM149_ABS];
	  else
	    ptr = (long)RDB[loc0 + SIM_B1_SM149_ABS];
	  
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  fprintf(fp, "%12.5E", RDB[ptr + 1]);
	  
	  /* Macroscopic Sm-149 capture cross section in thermal group */ 
	  
	  if ((long)RDB[DATA_B1_CALC] == NO)
	    ptr = (long)RDB[loc0 + SIM_INF_SM149_MACRO_ABS];
	  else
	    ptr = (long)RDB[loc0 + SIM_B1_SM149_MACRO_ABS];
	  
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  fprintf(fp, "%12.5E", RDB[ptr + 1]);
	  
	  /* Boron cross sections */
	  
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E\n", 0.0, 0.0, 0.0, 0.0);
	  
	  /* Card 6 (more group constants) */
	  
	  /* 2-group k-inf */
	  
	  if ((abs1 + rem > 0.0) && (abs2 > 0.0))
	    k = (nsf1 + nsf2*rem/abs2)/(abs1 + rem);
	  else
	    k = 0.0;
	  
	  fprintf(fp, "%12.5f", k);
	  
	  /* 2-group migration area */
	  
	  if ((abs1 + rem > 0.0) && (abs2 > 0.0))
	    M2 = D1/(abs1 + rem) + D2/abs2;
	  else
	    M2 = 0.0;
	  
	  fprintf(fp, "%12.2f", M2);
	  
	  /* Material buckling */
	  
	  if (M2 != 0.0)
	    B2 = (k - 1)/M2;
	  else
	    B2 = 0.0;
	  
	  fprintf(fp, "%12.3E", B2);
	  
	  /* Other stuff */
	  
	  fprintf(fp, "%12.5E%12.5E%12.5E\n", 0.0, 0.0, 0.0);
	  
	  /* Card 7 (more group constants) */
	  
	  /* Nu-values */
	  
	  if (fiss1 > 0.0)
	    fprintf(fp, "%12.5E", nsf1/fiss1);
	  else
	    fprintf(fp, "%12.5E", 0.0);
	  
	  if (fiss2 > 0.0)
	    fprintf(fp, "%12.5E", nsf2/fiss2);
	  else
	    fprintf(fp, "%12.5E", 0.0);
	  
	  /* Energy per fission (Ws/fiss, group-wise) */

	  if ((long)RDB[DATA_B1_CALC] == NO)
	    ptr = (long)RDB[loc0 + SIM_INF_KAPPA];
	  else
	    ptr = (long)RDB[loc0 + SIM_B1_KAPPA];
	  
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  fprintf(fp, "%12.5E%12.5E\n", MEV*RDB[ptr], MEV*RDB[ptr + 1]);
	}
      else
	{
	  /* Print zeros */

	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E%12.5E%12.5E\n", 
		  0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E%12.5E%12.5E\n", 
		  0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E%12.5E%12.5E\n", 
		  0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E%12.5E%12.5E\n", 
		  0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E%12.5E%12.5E\n", 
		  0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E\n",
		  0.0, 0.0, 0.0, 0.0);
	}

      /***********************************************************************/
 
      /***** DEL Data block **************************************************/

      /* Check number of precursor groups */

      if ((long)RDB[loc0 + SIM_NDG] == 6)
	{
	  /* Card 1 */

	  fprintf(fp, "%-72s%2d%3d%3ld\n", "DEL", 1, 5, stp);
	  
	  /* Card 2 (Delayed neutron yield in 6 groups )*/
	  
	  ptr = (long)RDB[loc0 + SIM_BETA_ZERO];
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  for (n = 0; n < 6; n++)
	    fprintf(fp, "%12.5E", RDB[ptr + n + 1]);
	  
	  fprintf(fp, "\n");
	  
	  /* Card 3 (Effective delayed neutron yield in 6 groups) */
	  
	  ptr = (long)RDB[loc0 + SIM_BETA_EFF];
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  for (n = 0; n < 6; n++)
	    fprintf(fp, "%12.5E", RDB[ptr + n + 1]);
	  
	  fprintf(fp, "\n");
	  
	  /* Card 4 (Decay constants for delayed neutron groups) */
	  
	  ptr = (long)RDB[loc0 + SIM_LAMBDA];
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  for (n = 0; n < 6; n++)
	    fprintf(fp, "%12.5E", RDB[ptr + n + 1]);
	  
	  fprintf(fp, "\n");
	  
	  /* Card 5 (Misc. data) */
	  
	  ptr = (long)RDB[loc0 + SIM_BETA_ZERO];
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  fprintf(fp, "%12.5E", RDB[ptr]);
	  
	  ptr = (long)RDB[loc0 + SIM_BETA_EFF];
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  fprintf(fp, "%12.5E", RDB[ptr]);
	  
	  /* Neutron generation time */

	  ptr = (long)RDB[loc0 + SIM_NEUTRON_GENTIME];
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);

	  fprintf(fp, "%12.5E", RDB[ptr]);
	  
	  fprintf(fp, "%12.5E%12.5E\n", 0.0, 0.0);
	  
	  /* Card 6 (Inverse velocities) */
	  
	  ptr = (long)RDB[loc0 + SIM_RECIPVEL];
	  CheckPointer(FUNCTION_NAME, "(ptr)", DATA_ARRAY, ptr);
	  
	  for (n = 0; n < 2; n++)
	    fprintf(fp, "%12.5E", RDB[ptr + n + 1]);
	  
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E\n", 0.0, 0.0, 0.0, 0.0);
	}
      else
	{
	  /* Card 1 */

	  fprintf(fp, "%-72s%2d%3d%3ld\n", "DEL", 1, 5, stp);

	  /* Print zeros */

	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E%12.5E%12.5E\n", 
		  0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E%12.5E%12.5E\n", 
		  0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E%12.5E%12.5E\n", 
		  0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E\n",
		  0.0, 0.0, 0.0, 0.0);
	  fprintf(fp, "%12.5E%12.5E%12.5E%12.5E%12.5E%12.5E\n", 
		  0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	}

      /***********************************************************************/

      /* Next statepoint */

      loc0 = NextItem(loc0);
    }

  /* Close file */

  fclose(fp);
}

/*****************************************************************************/
